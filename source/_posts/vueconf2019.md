---
title: vueconf2019
date: 2019-06-08 20:06:08
tags: 学习
category
    - 会议
---

### 前言
> 今天第一次去参加技术性的会议，作为一个菜鸟代码搬运工。可以说，更多的是感受大佬们的精神了。就像尤大说的：“只要有人还在用vue，我们就会持续维护”。虽说现在是寒冬季，但是这些开发者还是依旧坚持着做分享做他们的工作，工作和工作也是可以部分分开的。然后今天的主要需要深入学习的还是那些经常被提起的通信编译之类的基础知识。除开上午的一些关于vue3.0和测试的东西外，后面的重头在移动端的方案上面。宣讲者说是结合了vue但是里面的东西已经不是一般认识的web-vue了或者说web-react。

### vue3.0的性能优化
vue3.0的优化讲到了class-api的问题以及装饰器的支持和diff算法的大概优化思路。前两个和api主要是对于一些范式的支持，涉及应用的主要还是diff。vue的vdom还没有仔细看是一个什么意思，只能大概从react的去理解了。看这些之前也有看过一点qtwebkit的源码分析，那么其实vdom大概就是可以理解成一个数据结构从jsobject树到dom树的映射，扩展了dom的附加功能并标记了一个个dom。
```
                                body[attr, data, className]
                            div[...]    p[...]
                        span[...]               b[...]
#### 这个是原始的HTML文件，从浏览器下载到最后渲染大致过程是
1.下载html文本
2.词法解析器去分析文本
3.qtwebkit的内核解析html标签实例化c++内部实现的html类attr属性类，继承事件类扩展html类【xml文件解析成数据大致也是这个感觉，只是这个扩展了数据的功能】
#### 对html的标准的表象支持多半也就在上两部实现了，这里也就想到崔红保大佬说的比较脏的点了也就是建立视图语言之间模型的映射工作，不是一点的脏。涉及到多平台视图语言的桥接工作。
4.将实例的数据注入到js容器的宿主中winodw中，提供了访问qt视图的操作能力，主要还是提供了修改背后实例的html标签实例数据的能力。
5.每次修改html都会是修改背后的c++数据
#### 所以为什么说大数据量的dom交互频繁的setData是影响性能的一个要素呢。就是因为它其实是在频繁的进行两个语言之间的进程或者线程之间的通信，这个代价就是那么可怕。
#### 这也是vdom出现的愿意，批次修改数据一次更新。

回到vdom上，html-dom完成的是从dom到qt的视图类数据的映射，vdom其实也是借助的这个模型。从vdom到dom的映射并扩充了运行时的dom信息，比如fiber中的渲染事件渲染队列以及是否在渲染中。

        <body>          
<span>          <p>
映射关系
{
    type: 'body',
    attr: 'id',
    time: 12312313,
    updateQueue: [],
    children: [
        {....}
        {....}
    ]
}
```
所以还是一个多叉树的结构，那么就说优化上了。按尤大说的从上到下的查找更新点，首先要从根找起找到更新节点，小规模的树其实还好，大规模的树光是查找就是很费时间的。3.0采用的更新方案是在需要更改的地方才做更改，那么就是这么个意思了。
```
<templte>
    <div>{{ message }}</div>
    <p>1</p>
</templte>
编译-从文本信息到数据信息，在这个部分中对可能存在变动的节点加入监听当然也可能是其他方式,只是说从处理整个树的查找操作来猜的方案。
{
    type: 'tem'
    children: [
        {
            type: 'div'
            text: ${message}
        },
        {...}
    ]
}
在type为div的这个类型实例化的时候它是可能存在变动的所以就需要特殊处理了。加proxy或者其他的操作，其他的直接渲染。也就不至于不管会不会存在变动都对每个实例对象做proxy或者其他的操作，增加内存开消耗。
```
按qtwebkit的做法这样的文件还是会转成自己支持的视图数据，存在一个编译过程框架里也是如此了。读到div时发现有一个变量引用给这个div类型的做标记，那么其实就只会检测这一块的变动了。至于到html的更新，小范围更新，参照react实例话的vdom数据，内部是包含渲染后的dom节点的实际信息。这个信息其实就是用来直接找到实际的dom节点进行更新而不是重新渲染整颗数据树。剩下的像classapi和装饰器是在语言层面的增强，不涉及具体的业务和平台跨端方案。

### vue的多端方案
了解vue的多端方案前或者hybrid之前，其实看看qtwebkit部分源码大概也是能明白这个思路的，实际工程另说了，因为你看懂了说不定还是不会写这就让人很悲伤了。
今天的多端方案的话主要在小程序，有百度的方案也有uni-app的。原理还是得看源码，但是具体思路整体听下来和传统web都是八九不离十的样子。多端的话还是涉及到双语言线程或者多语言线程的通信，今天有个很典型的问题就是有位同学提到的，大概意思是既然绕了一大圈之前外放了一些接口给前端去做操作为什么不把数据处理权限也放到前端处理，快手大佬的意思是涉及到数据同步。
```
#### 如果做这样一个处理的话，可能类似于
#### 两端的data其实都是为了表达视图信息，但是在两端都做了一个存放，如果数据同步出错或者不顺畅确实是问题
#### 参考前后端的数据同步，或者react组件之间的数据同步。
appClient[data] ===== Native[data]
```
其实从现有的web一端还是能看出一点多端的思路的，从内核的事件注册这个功能来看从系统到背后语言到前端语言的转化过程中对于语言或者系统api外放的处理。这也是api接口设计工作的一部分也能学习怎么做两个系统间的对接。
继续qtwebkit，我们来说说它的node节点类的架构,集体细节不太记得了但是大概能描述出它的大体架构和系统功能的对接，具体的有一篇专门讲webkit内核的博客配合开源的qtwebkit代码库食用非常棒。
```
                node
        Element       Attr
    Style       Event    
```
Style类用来做样式处理和计算工作的对标的style属性，Attr对标的attr，event对标的事件处理。这些都是用来去做继承的父类，我们知道c++是可以做多继承的【为毛js不做多继承，一个个继承真的有点繁琐】。event类负责对接的是整个操作系统的事件处理。它的过程大致是一下几步：
1.首先词法分析html
2.实例化node，node类底层继承了event所以同时将操作函数addevent【不记得名字了大概就是这么个鬼东西】
3.将实例数据注入到宿主的window.document中
4.编程时调用宿主中同名的注册函数，实现从js线程到c++线程的通信
5.到c++这层接收到对应的映射数据的注册请求调用底层的event类的功能将事件监听注册到队列中，同时event会监听系统的操作
6.鼠标或者其他操作的目标在qt的界面中时，触发监听
7.通知并触发前端的注册
所以这也就是为什么会曾在事件的传导问题，就是因为dom的监听其实是对整个的监听。

从qt去学的话，templete，jsx是关于webview视图数据的映射，承载的是底层的node类的功能。而其他多端的方案template或者其他的文本信息承载的是安卓或者ios的视图语言，也就产生了一种感觉虽然其他端的人是在说支持vue，但是vue真正做的工作是做对接，然后因为国内的vue开发者很多为了省去学习成本在写法上的亲和。底层的桥接工作或许已经面目全非了。封装一套视图操作类，注入到jscore中，开发者能在其中访问其他语言线程暴露给开发者的一些操作权限，JSCOR或者window承担了容器的工作。总体感受会议还是以技术方案为主，如果想深入学习的话还是要进入算法，进程线程内存管理调度，这个绕不开。vdom的关于多叉树的算法，多端方案中的线程通信，内核实现的对js应用内存的管理。实质上js它真的也就不对接操作系统就是应用之上的扩展语言，很面向业务。