{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"a跳转操作","text":"超链接标签html中的a标签超链接可以实现，开启新tab，下载，跳转，锚点，调起外部功能。 跳转连接利用a标签进行路由跳转1&lt;a href=&quot;www.zhihu.com&quot; title=&quot;知乎&quot;&gt;知乎&lt;/a&gt; 开启tab利用a标签跳转页面打开新页面1&lt;a href=&quot;www.zhihu.com&quot; title=&quot;知乎&quot; target=&quot;_target&quot;&gt;知乎&lt;/a&gt; 锚点利用a标签跳转到页面的其他地方1&lt;a href=&quot;#&quot;&gt;返回页面顶部&lt;/a&gt; 下载连接进行资源下载1&lt;a href=&quot;*****&quot; download&gt;文档&lt;/a&gt; 调起外部服务123456### 移动端电话拨打&lt;a href=&quot;tel:+134*******&quot;&gt;联系电话&lt;/a&gt;### 邮件发送&lt;a href=“mailto:error_lwei@163.com”&gt;发送给谁&lt;/a&gt;### 抄送&lt;a href=&quot;mailto:error_lwei@163.com&quot; cc=&quot;lemonpaimc@163.com&quot;&gt;抄送&lt;/a&gt;","link":"/2019/05/23/a跳转操作/"},{"title":"typecript中的reflectApi元编程","text":"元编程 元编程（Metaprogramming）是指某类计算机程序的编写，这类计算机程序编写或者操纵其他程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高。编写元程序的语言称之为元语言，被操作的语言称之为目标语言。一门语言同时也是自身的元语言的能力称之为反射。 这个是一个很抽象的概念，作为非计算机类专业的好像也不太好班门弄斧去解释这个概念。只能从字面去说一下自己的认识。“元编程”字面就是对原子进行编程，在具体使用中这个原子可以细化到一个变量也可以扩展到一个函数功能和一个对象。编程的概念其实描述的是一个过程，从输入到产出的一个整体的过程，开发者通过代码参与这个过程控制过程的流向。元编程的话，假设在一个过程中有一个a功能对象是专门用于处理一个订单分发策略的，那么这其中一定会有根据不同的标注信息做不同的动作，虽然同一个功能对象但是能根据不同的信息产生不同的效果（可能这就是控制反转，在不修改代码内部的情况下通过外部标注信息的修改达到修改结果的目的）。 123456789101112import &apos;reflect-metadata&apos;;@Module({ import: [], controller: [], exports: [],})class Test { constructor(props) {} @Reflect.metadata(&apos;hello&apos;, &apos;word&apos;) getService() {}} 利用reflect对类进行元数据的添加，在class外和class内使用装饰器去处理target目标有所不同。module部分修饰的目标是类本身，metadata部分修饰的是类的原型链对象prototype上的属性。前者如果在程序启动后获取的一般是未实例化下的类型注解，后者能获取到的注解信息是实例化后的对象的。 nestjs使用注解对元子进行操作的特点类型注解@Module这个是注解一个模块类型的，在nest去编写node服务时使用module表明这是一个模块类型的类，同时在内部做到了从path资源路径到module的关联。内部做到将module名称转换到path的过程，同时module的概念包含了service与import信息。12345678例：/user/info/add/user/msg/detail这样一个资源路径转换成module user info msgadd detail应用的全局其实就维护着这样一个信息，信息的获取与组织就通过注解去完成了。 每一个类型注解对应一套处理规则，module类型用于组织资源的关联信息Inject类型负责组织在module类传递的服务依赖信息。说回module的另一个注解信息exports，exports的功能用于导出service服务。无导出情况下service操作只在module内部可见，有导出操作后module的service功能在父子兄弟之间传递共享，所要应对的情况是：在detail内可能需要调用add的数据操作功能，因为service操作最终还是db操作的实体化。所以需要具备导出操作。12345678import起到连接module的作用建立上下级关系同时具备service的传导操作 importuser =&gt; infouser =&gt; msg serviceuser &lt;= infouser &lt;= msg这类似与在父进程中兄弟线程的共享内存 依赖注入直观点按nest的操作来看就是123456789101112131415@module({ import: [], controller: [UserController], provider: [UserService]})class User {}// 内部其实大概是这样的new UserController(new UserService)class UserService { constructor(userservice: UserService) {}}// 注入的过程在工厂函数构建应用时完成的 操作应用组织完成后，从前端调用接口到最后的数据操作大概要走下面的过程1db &lt;= service &lt;= controller 模型转到前端把这套方式转到前端处理的化，视图层先不管那只是很外在的东西不管界面长得千奇百怪最后还是要进行操作执行action去触发请求动作。所以重要的是收集存在的action动作信息更新创建等如果用saga的task概念去管理异步的化就可以将一个动作集合整合到一个task任务中去处理减少在视图层的组合请求动作（如前后一个动作依赖前一个动作的结果）这样能减少视图层逻辑的复杂度，增加应用的移植性，另外在saga中有管道的概念相同的动作能做到顺序执行并能暂停和重启回退这对于频繁的操作能起到很好的抗压作用。所以重要点其实不在视图层而是在redux应用的整个action动作的流程。 redux应用的中心redux应用的整体使用状态去控制，一个action触发的是一个操作状态ADD_DETAIL之类的。需要组织的是应用的状态管理。那么基础的元数据就是应用的状态一个函数是用来处理何种状态的。123对应关系db &lt;= service &lt;= controllerstore &lt;= action &lt;= view store1234567891011121314@Store(&apos;user&apos;)class User { constructor() {} @type(&apos;ADD_USER&apos;) function add(state, action) { ...... } @type(&apos;UPDATA_USER&apos;) function updata(state, action) { ...... }} action1234567891011121314@Action()class UserAction { constructor(user: User) {} @post(&apos;/api/user&apos;, &apos;json&apos;) function add(params) { return { type: user.ADD_USER params: { ...params } } }} view12345678910@Viewclass User extends React.Component { constructor() {}}function View(state, action) { return function(Target) { return connect(state, action)(Target) }} importnest中import完成了module中资源路径前前后关系，转换到前端可以用import去关系整个路由的前后关系。这样也省去前端去管理路由的额外的开发时间。 最主要的还是借鉴nest的方式想将应用的路由，api，状态管理的额外开发量合并到开发具体功能中省去这部分的时长。这部分的信息大多散落在各个文件中，不利于管理。","link":"/2019/05/30/typecript中的reflectApi元编程/"},{"title":"vueconf","text":"前言 基于对之前的一版不太满意的原因的下，今天做了两张图细化一下。同时更想说清楚为什么会出现vdom，以及进行react和vue的跨平台方案的切入点到底在哪里。看多端方案和vdom之前其实还是有必要去看原始web开发的实际生产中怎么做到从html，js到浏览器应用的这个过程，这个对于多端方案的理解是有很大帮助，现有多端方案细化的点不是很清楚，但是在大的架构方面都是相差不大的。 web端开发web应用其实可以解释成浏览器的子产品和小程序如出一辙，只是宿主平台不一样。企业或用户的产品都是运行在同一个应用上的，chrome本身就是一个产品你开多少个浏览器访问多少个网站都是在这个宿主上去做事情。看宿主和web应用或者hybrid或者是react-native，大的方式都是一致的，宿主对于用户操作通用行为的封装暴露出接口，同时抽象一套视图系统，同时将视图系统与系统操作能力注入到JScore中。宿主所能提供的就是前进后退，操作响应，网络与文件io，设备调用这些通用的业务功能，至于是付款还是表单输入信息，输入的是什么这些上层操作就不在宿主考虑的范围了，如果掺入了细化的逻辑，在通用性上宿主的功能就越界了变的不纯粹了。web业务或者html与js有热度的原因很大一部分在于，它的移植性十分的强。包括nodejs，应用逻辑和宿主的关系并不是很紧密，业务代码更大一部分放在了js这端。 浏览器的功能结构从web前端转换到其他端js前端开发时，其实回头继续看浏览器就可以了，js在其中的位置大致相同。如果只是做js这端的基础开发只需要了解js引擎与宿主的对接关系就能处理了。 这个是qtwebkit的整体结构，web浏览器外部对接一个js引擎，一个操作系统，一个文档系统。脚本系统不与文档系统直接对接，文档系统的作用就只在初始化视图时用到，剩下的我们看到的dom数据是宿主根据文档数据转化成的视图对象然后注入到js引擎中的。123456### html文档用来申明一个node类的类型，以及类型具备的功能参数的，img表示是图片类型，src表示下载的功能参数，title表示浮窗功能。### 如果用不支持图片格式的软件打开图片，图片就是下面这种信息。0101 1100 0010 ...1111 0000 1001 ...### 具体它的解析器规则假设0101代表的是rgba中的每一个，而这每四个构成一个像素的表达,它就是一个屏幕图像信息的表示了。### 表达方式可以是任何形式，只要有对应的解释器。html的&lt;img src=&quot;&quot; /&gt;也是一样，有相应的解释器去解释这一段字符串。 HTMLTokenizerHTMLTokenizer是内核中的一个c++类，用来做词法分析检验文档词法的合法性。是从字节流到特定格式的字符串。网页头部设置的utf-8就是帮助词法分析器去做字节处理的，当然不输的话也能自己找到匹配的解析方式，内置的nextToken函数会循环去读每读取一段就标记一段的处理状态并输出一个解释的词语。12### 在界面上看到html文档可能是utf-8,不过在下载完成后是从一种文件系统到另一个系统的对接，文件会被直接转成字节码。### HTMLTokenizer 的具体功能就是用来做字节流的解码的。转化成能认识的编码。如果是不支持的编码方式。也就出现了有时候看到的乱码，乱码出现的点就是在HTMLTokenizer这里了。 命名还是很好理解的，所以写啥注释，命名好了大概就是提示了。 这其中也包含一部分xss攻击的处理，对于包含非法信息的标签进行过滤。在进行视图对接前就将数据处理干净，默默的感觉有点像接口参数校验。 HTMLDocumentParser虽然HTMLDocumentParser与HTMLTokenizer是两个不同的小系统，但他们在整体里面所起到的作用是近似的都是在做前置数据的准备。一个负责检查转译筛选，一个负责将它转变成另一种形式，HTMLDocumentParser所做的工作就是将词语转成节点。这个处理过程是已栈的方式去做的，即遇到&lt; 标记开始入栈 遇到&lt;/标记进行出栈。1234567## 解析下面一段文本的方式&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;[div,p][div][]先压入div标签，再压入p标签，处理完p之后再处理完div最后div出栈&lt;img src=&quot;...&quot; /&gt; =&gt; { type: &apos;img&apos;, src: &apos;....&apos;, .... } \bHTMLDocumentParser内部调用的是HTMLTreeBuilder的constructTree方法进行词语到节点的转化，然后看c++的语法是真漂亮虽然多很多代码。其中很多这种std::是它的智能指针功能，内部有引用计数做垃圾回收。经过前两步处理完的数据最后的节点信息就是即将进行渲染的信息，html和js交互处理的实际上是这部分信息，比如在html加载的过程遇到js控制dom更改的过程。GUI和js访问的是同一个资源信息，GUI根据节点信息渲染dom，当js申请操作修改时节点信息就被锁住，GUI工作就需要被暂停，当js修改信息完成资源访问就被释放。 node系统node系统可以说是webkit最核心的功能，它赋予了js中的document下所有dom中的各种能力，比如调用底层注册事件等。不能完全看明白或者理解oop是什么，不过能学习到如何通过oop的方式去进行多系统的对接，可以把node与其他系统的连接看成下面这种形式。 1234567891011121314151617181920212223242526272829303132333435class Event { constructor() { } static queue = []; add() {...} remove() {...}}class GuI { constructor() {} static render() { sys.Gui() } start() {....} stop() {....}}class Src { constructor() {} Io(src) { sys.Io(src); }}class Node extends Event, GuI { constructor() { super(); } ....} react中通过继承做界面的组合真的比较懒所以这个图真的有点丑！这个方式是从其他人那里学到的，不过他的方式是不做整体页面的组合，都是做颗粒度比较小的界面部件的类型封装，这种是很灵活的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485### js没有多继承搞这种真的是有点不舒服### 一层层的拆成小的碎片class Search extends React.Component { constructor(props) { super(props); this.state = { param: {}, } this.initState(); } initState(param) { return null; } /** 获取表单数据 **/ getFormData() { ...... 暴露给外部获取数据 } /** 过滤表单数据 **/ filterFormData() { ...... 内部功能函数 } render() { return ( &lt;div&gt;{ 视图逻辑 }&lt;/div&gt; ) }}class SearchBtn extends Search { constructor(props) { super(props); } /** 与外部对接的过程 **/ onSubmitReq(param) { return null; } /** 内部处理过程 **/ onSubmit() { const data = this.getFormData(); this.onSubmit(data); } render() { return ( &lt;div&gt; { super.render() } &lt;div&gt; { 按钮视图 } &lt;/div&gt; &lt;/div&gt; ) }}class List extends SearchBtn { constructor(props) { super(props); } initState() { this.state.list = []; } onSubmitReq(params) { api(params); } render() { return ( &lt;div&gt; { super.render() } &lt;table&gt; &lt;/div&gt; ) }} node通过继承将各种能力添加到dom中，拆看来看单个父类的功能是很纯净的。在Event中自己维护和系统事件的对接，当监听到某一事件的触发，就调用注册的监听的控制器传入上层，在底层系统中的事件处理是没有目标的这个概念只有事件类型input类型事件click类型事件。这个处理方式也是对于本系统可控的方式的一点，系统的边界必须明确，比如从a-b的对接，其实我并不知道具体是a里面的谁要求做了这件事,事实是b也不需要知道。如果b连谁做了也要分析的话今天有abc申请了明天有mgn申请了，那这也太头痛了我只需要知道自己能处理的是input操作click操作处理了就丢出去你自己找是谁申请的。所以到前端这边也就存在了捕获和冒泡这种东西。为了保持底层的在移植的过程中的通用性。同时将对接的多个能力拆分到不同的类型中，分散治理将功能隔离开。 12345function add(a, b, c, d) { ....... // **从一个应用到另一个应用** sys.add(a,b,c)} 最后再回想conf上崔红保大佬说的不要频繁setData,以及为什么会出现vdom这个东西。由于js去直接操作dom不是在前端这边操作数据而是调用内核暴露出来的能力去修改内核中存储的dom节点信息。在信息不大的情况下其实都还好，大数据量的dom操作情况下相当于频繁的从a-b-c-d而且是从一个系统到另一系统的调用一个线程到另一个线程的通信。这个代价是高的，既然视图都是从数据去转成视图的，那前端先处理好视图数据最后集体调内核能力，vdom就是视图数据在前端的一种体现因为要做时间切片等优化在数据上又扩充了一些其他信息，react的fiber架构中单个节点中出现的time信息就是一个例子。 vdomvdom有点像在js这端做的从html到节点转换的工作，当然附加了更多的运行时的数据，包含原有dom比原有dom的信息更丰富。react，vue之前的dom是由html文档提供初始化的视图数据浏览器解析然后返回到js，js属于直接操作dom，因为js本地其实是不存储视图关系（也可以用jq去实现vdom），所以有更改就要直接调用api操作浏览器内部的数据，vdom所解决的就是视图数据在前端的管理以及控制js这端调用浏览器操作的频率。 12345678updatequeue = [vdom1, vdom2, vdom3, vdom4];// 每个vdom包含扩展信息又包含原始信息，始终能根据原始信息找到对应的原始dom和调用原始dom的apivdom = { dom: dom, time: 123, vdomobject: {}, }当调用set的时候更新并推到队列里，如果一个时间片内的长度是5，那么当有5个更新节点时就一次推动更新。当然描述可能存在误差但是主要是想表明在这里面，先借助vdom做前置处理，最后反应结果到dom上。 到这里其实多端方案的思路其实也比较清楚了，深入的话就到实际开发中去了。 react时间切片更新方案的大概方式由于vdom是对于dom的一种反应，所以在前端js层是一个多叉树的结构去存储视图数据的，每个节点就是一个完整的fiber。前端开发使用vue或者react这套方案去做本质还是对一颗树的节点进行操作。所以，就会涉及到对于树的查找对于树的节点替换更新。多叉树的查找性能随着树的深度而加深，diff方案优化的是在前端对于数据树中的单个更新节点的查找，最后的更新还是整棵树的更新。 来看下react的最小更新方案，\breact的fiber方案中。在单个节点也会存在一个updatequeue，如果打印一下父子组件的生命周期会发现它的过程是先子组件触发然后父子组件触发，它的更新方案是节点内的自治自下而上的传导，也就是小范围内的触发更新。vueconf上3.0说依旧保持模版方案，并且会加入动静结合的方式对存在变动的节点加入监听自己的理解应该也是这么个意思。在将模版信息转成对象信息的时候在这个转化的过程中就会插入记录有花括号的或者有for循环，就是揭露有可能存在更改的更改的节点，因为vue是以劫持的方式去监听更新的，如果用代理的方式去处理每个节点都创建一个代理对象，这自然在性能上是很大的开销因为你会为此加入类型推导判断是否存在变化，也就是在运行时不管有没有变化都会做判断逻辑，也就必然存在时间的增加。这和要求我们尽量是用const不用let是一个意思，const声明的是常量不会存在类型变化，v8内核不会在运行时不会为此做类型变化的判断。另外在尤大提到的3.0将去除class和装饰器的支持之前自己是很喜欢用装饰器的也并没有考虑到装饰器带来的不稳定性，这涉及到函数的返回副作用，这个也是监测点。12345678#### react的高阶函数function Component(Target) { return class extends React.Component { }}高阶函数的副作用在于尽管在代码层面看起来他们都是一样的结构，但是函数的返回始终是一个新的对象，他们其实并不相等。代码存在复用，在实际的运行时内存中的数据不存在复用。js的函数参数的指针是隐式的，即不管传入的参数是否在函数内有操作，所返回的值都是要在内存中创建一个新的数据与指针，存在空间的损耗。 真正的更新操作是，js在一定的周期内内部自治完成对节点信息的替换更新，然后调用api将维护完的数据树同步到浏览器中。像上图中的两颗树，当某个范围内的节点触发set时，将js存储的数据树中关于视图部分的信息更新掉。12345678910111213{ type: &apos;div&apos;, data: { list: [1,2,3], }, html: `&lt;div&gt;{ this.list }&lt;/div&gt;`}{ data: { list: [3,4,5], }, html: `&lt;div&gt;{ this.list }&lt;/div&gt;`} 像这样的节点整颗更新掉之后，html的信息其实已经替换成最新的，然后innerhtml=*。触发浏览器的视图刷新，这样就避免了一次次的调用api，也就变成了时间切片了，在一定时间内我这边自己做好处理再通知你。 现在的多端方案使用vue和react，借用的点是什么？其他端和浏览器是一致的，他们唯一借助的点是vue和react关于视图数据的管理和更新。唯一存在魔改的点在视图功能的对接口，即在浏览器端src和title可能对应的是node类中的一中功能，在安卓端这两个属性对应的实现点又是另一种方式。1&lt;img src=**** title=***/&gt; 所以慢慢的有一种感觉就是虽然都是react和vue但是其实已经不是之前在web端使用的了。","link":"/2019/06/09/vueconf/"}],"tags":[{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"reflect","slug":"reflect","link":"/tags/reflect/"},{"name":"vueconf","slug":"vueconf","link":"/tags/vueconf/"}],"categories":[{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"},{"name":"笔记","slug":"笔记","link":"/categories/笔记/"}]}