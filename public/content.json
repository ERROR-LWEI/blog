{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"vueconf2019","text":"前言 今天第一次去参加技术性的会议，作为一个菜鸟代码搬运工。可以说，更多的是感受大佬们的精神了。就像尤大说的：“只要有人还在用vue，我们就会持续维护”。虽说现在是寒冬季，但是这些开发者还是依旧坚持着做分享做他们的工作，工作和工作也是可以部分分开的。然后今天的主要需要深入学习的还是那些经常被提起的通信编译之类的基础知识。除开上午的一些关于vue3.0和测试的东西外，后面的重头在移动端的方案上面。宣讲者说是结合了vue但是里面的东西已经不是一般认识的web-vue了或者说web-react。 vue3.0的性能优化vue3.0的优化讲到了class-api的问题以及装饰器的支持和diff算法的大概优化思路。前两个和api主要是对于一些范式的支持，涉及应用的主要还是diff。vue的vdom还没有仔细看是一个什么意思，只能大概从react的去理解了。看这些之前也有看过一点qtwebkit的源码分析，那么其实vdom大概就是可以理解成一个数据结构从jsobject树到dom树的映射，扩展了dom的附加功能并标记了一个个dom。12345678910111213141516171819202122232425262728 body[attr, data, className] div[...] p[...] span[...] b[...]#### 这个是原始的\b\bHTML文件，从浏览器下载到最后渲染大致过程是1.下载html文本2.词法解析器去分析文本3.qtwebkit的内核解析html标签实例化c++内部实现的html类attr属性类，继承事件类扩展html类【xml文件解析成数据大致也是这个感觉，只是这个扩展了数据的功能】#### 对html的标准的表象支持多半也就在上两部实现了，这里也就想到崔红保大佬说的比较脏的点了也就是建立视图语言之间模型的映射工作，不是一点的脏。涉及到多平台视图语言的桥接工作。4.将实例的数据注入到js容器的宿主中winodw中，提供了访问qt视图的操作能力，主要还是提供了修改背后实例的html标签实例数据的能力。5.每次修改html都会是修改背后的c++数据#### 所以为什么说大数据量的dom交互频繁的setData是影响性能的一个要素呢。就是因为它其实是在频繁的进行两个语言之间的进程或者线程之间的通信，这个代价就是那么可怕。#### 这也是vdom出现的愿意，批次修改数据一次更新。回到vdom上，html-dom完成的是从dom到qt的视图类数据的映射，vdom其实也是借助的这个模型。从vdom到dom的映射并扩充了运行时的dom信息，比如fiber中的渲染事件渲染队列以及是否在渲染中。 &lt;body&gt; &lt;span&gt; &lt;p&gt;映射关系{ type: &apos;body&apos;, attr: &apos;id&apos;, time: 12312313, updateQueue: [], children: [ {....} {....} ]} 所以还是一个多叉树的结构，那么就说优化上了。按尤大说的从上到下的查找更新点，首先要从根找起找到更新节点，小规模的树其实还好，大规模的树光是查找就是很费时间的。3.0采用的更新方案是在需要更改的地方才做更改，那么就是这么个意思了。12345678910111213141516&lt;templte&gt; &lt;div&gt;{{ message }}&lt;/div&gt; &lt;p&gt;1&lt;/p&gt;&lt;/templte&gt;编译-从文本信息到数据信息，在这个部分中对可能存在变动的节点加入监听当然也可能是其他方式,只是说从处理整个树的查找操作来猜的方案。{ type: &apos;tem&apos; children: [ { type: &apos;div&apos; text: ${message} }, {...} ]}在type为div的这个类型实例化的时候它是可能存在变动的所以就需要特殊处理了。加proxy或者其他的操作，其他的直接渲染。也就不至于不管会不会存在变动都对每个实例对象做proxy或者其他的操作，增加内存开消耗。 按qtwebkit的做法这样的文件还是会转成自己支持的视图数据，存在一个编译过程框架里也是如此了。读到div时发现有一个变量引用给这个div类型的做标记，那么其实就只会检测这一块的变动了。至于到html的更新，小范围更新，参照react实例话的vdom数据，内部是包含渲染后的dom节点的实际信息。这个信息其实就是用来直接找到实际的dom节点进行更新而不是重新渲染整颗数据树。剩下的像classapi和装饰器是在语言层面的增强，不涉及具体的业务和平台跨端方案。 vue的多端方案了解vue的多端方案前或者hybrid之前，其实看看qtwebkit部分源码大概也是能明白这个思路的，实际工程另说了，因为你看懂了说不定还是不会写这就让人很悲伤了。今天的多端方案的话主要在小程序，有百度的方案也有uni-app的。原理还是得看源码，但是具体思路整体听下来和传统web都是八九不离十的样子。多端的话还是涉及到双语言线程或者多语言线程的通信，今天有个很典型的问题就是有位同学提到的，大概意思是既然绕了一大圈之前外放了一些接口给前端去做操作为什么不把数据处理权限也放到前端处理，快手大佬的意思是涉及到数据同步。1234#### 如果做这样一个处理的话，可能类似于#### 两端的data其实都是为了表达视图信息，但是在两端都做了一个存放，如果数据同步出错或者不顺畅确实是问题#### 参考前后端的数据同步，或者react组件之间的数据同步。appClient[data] ===== Native[data] 其实从现有的web一端还是能看出一点多端的思路的，从内核的事件注册这个功能来看从系统到背后语言到前端语言的转化过程中对于语言或者系统api外放的处理。这也是api接口设计工作的一部分也能学习怎么做两个系统间的对接。继续qtwebkit，我们来说说它的node节点类的架构,集体细节不太记得了但是大概能描述出它的大体架构和系统功能的对接，具体的有一篇专门讲webkit内核的博客配合开源的qtwebkit代码库食用非常棒。123 node \bElement AttrStyle Event Style类用来做样式处理和计算工作的对标的style属性，\bAttr对标的attr，event对标的事件处理。这些都是用来去做继承的父类，我们知道c++是可以做多继承的【为毛js不做多继承，一个个继承真的有点繁琐】。event类负责对接的是整个操作系统的事件处理。它的过程大致是一下几步：1.首先词法分析html2.实例化node，node类底层继承了event所以同时将操作函数addevent【不记得名字了大概就是这么个鬼东西】3.将实例数据注入到宿主的window.document中4.编程时调用宿主中同名的注册函数，实现从js线程到c++线程的通信5.到c++这层接收到对应的映射数据的注册请求调用底层的event类的功能将事件监听注册到队列中，同时event会监听系统的操作6.鼠标或者其他操作的目标在qt的界面中时，触发监听7.通知并触发前端的注册所以这也就是为什么会曾在事件的传导问题，就是因为dom的监听其实是对整个的监听。 从qt去学的话，templete，jsx是关于webview视图数据的映射，承载的是底层的node类的功能。而其他多端的方案template或者其他的文本信息承载的是安卓或者ios的视图语言，也就产生了一种感觉虽然其他端的人是在说支持vue，但是vue真正做的工作是做对接，然后因为国内的vue开发者很多为了省去学习成本在写法上的亲和。底层的桥接工作或许已经面目全非了。封装一套视图操作类，注入到jscore中，开发者能在其中访问其他语言线程暴露给开发者的一些操作权限，JSCOR或者window承担了容器的工作。总体感受会议还是以技术方案为主，如果想深入学习的话还是要进入算法，进程线程内存管理调度，这个绕不开。vdom的关于多叉树的算法，多端方案中的线程通信，内核实现的对js应用内存的管理。实质上js它真的也就不对接操作系统就是应用之上的扩展语言，很面向业务。","link":"/2019/06/08/vueconf2019/"},{"title":"a跳转操作","text":"超链接标签html中的a标签超链接可以实现，开启新tab，下载，跳转，锚点，调起外部功能。 跳转连接利用a标签进行路由跳转1&lt;a href=&quot;www.zhihu.com&quot; title=&quot;知乎&quot;&gt;知乎&lt;/a&gt; 开启tab利用a标签跳转页面打开新页面1&lt;a href=&quot;www.zhihu.com&quot; title=&quot;知乎&quot; target=&quot;_target&quot;&gt;知乎&lt;/a&gt; 锚点利用a标签跳转到页面的其他地方1&lt;a href=&quot;#&quot;&gt;返回页面顶部&lt;/a&gt; 下载连接进行资源下载1&lt;a href=&quot;*****&quot; download&gt;文档&lt;/a&gt; 调起外部服务123456### 移动端电话拨打&lt;a href=&quot;tel:+134*******&quot;&gt;联系电话&lt;/a&gt;### 邮件发送&lt;a href=“mailto:error_lwei@163.com”&gt;发送给谁&lt;/a&gt;### 抄送&lt;a href=&quot;mailto:error_lwei@163.com&quot; cc=&quot;lemonpaimc@163.com&quot;&gt;抄送&lt;/a&gt;","link":"/2019/05/23/a跳转操作/"},{"title":"typecript中的reflectApi元编程","text":"元编程 元编程（Metaprogramming）是指某类计算机程序的编写，这类计算机程序编写或者操纵其他程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下与手工编写全部代码相比工作效率更高。编写元程序的语言称之为元语言，被操作的语言称之为目标语言。一门语言同时也是自身的元语言的能力称之为反射。 这个是一个很抽象的概念，作为非计算机类专业的好像也不太好班门弄斧去解释这个概念。只能从字面去说一下自己的认识。“元编程”字面就是对原子进行编程，在具体使用中这个原子可以细化到一个变量也可以扩展到一个函数功能和一个对象。编程的概念其实描述的是一个过程，从输入到产出的一个整体的过程，开发者通过代码参与这个过程控制过程的流向。元编程的话，假设在一个过程中有一个a功能对象是专门用于处理一个订单分发策略的，那么这其中一定会有根据不同的标注信息做不同的动作，虽然同一个功能对象但是能根据不同的信息产生不同的效果（可能这就是控制反转，在不修改代码内部的情况下通过外部标注信息的修改达到修改结果的目的）。 123456789101112import &apos;reflect-metadata&apos;;@Module({ import: [], controller: [], exports: [],})class Test { constructor(props) {} @Reflect.metadata(&apos;hello&apos;, &apos;word&apos;) getService() {}} 利用reflect对类进行元数据的添加，在class外和class内使用装饰器去处理target目标有所不同。module部分修饰的目标是类本身，metadata部分修饰的是类的原型链对象prototype上的属性。前者如果在程序启动后获取的一般是未实例化下的类型注解，后者能获取到的注解信息是实例化后的对象的。 nestjs使用注解对元子进行操作的特点类型注解@Module这个是注解一个模块类型的，在nest去编写node服务时使用module表明这是一个模块类型的类，同时在内部做到了从path资源路径到module的关联。内部做到将module名称转换到path的过程，同时module的概念包含了service与import信息。12345678例：/user/info/add/user/msg/detail这样一个资源路径转换成module user info msgadd detail应用的全局其实就维护着这样一个信息，信息的获取与组织就通过注解去完成了。 每一个类型注解对应一套处理规则，module类型用于组织资源的关联信息Inject类型负责组织在module类传递的服务依赖信息。说回module的另一个注解信息exports，exports的功能用于导出service服务。无导出情况下service操作只在module内部可见，有导出操作后module的service功能在父子兄弟之间传递共享，所要应对的情况是：在detail内可能需要调用add的数据操作功能，因为service操作最终还是db操作的实体化。所以需要具备导出操作。12345678import起到连接module的作用建立上下级关系同时具备service的传导操作 importuser =&gt; infouser =&gt; msg serviceuser &lt;= infouser &lt;= msg这类似与在父进程中兄弟线程的共享内存 依赖注入直观点按nest的操作来看就是123456789101112131415@module({ import: [], controller: [UserController], provider: [UserService]})class User {}// 内部其实大概是这样的new UserController(new UserService)class UserService { constructor(userservice: UserService) {}}// 注入的过程在工厂函数构建应用时完成的 操作应用组织完成后，从前端调用接口到最后的数据操作大概要走下面的过程1db &lt;= service &lt;= controller 模型转到前端把这套方式转到前端处理的化，视图层先不管那只是很外在的东西不管界面长得千奇百怪最后还是要进行操作执行action去触发请求动作。所以重要的是收集存在的action动作信息更新创建等如果用saga的task概念去管理异步的化就可以将一个动作集合整合到一个task任务中去处理减少在视图层的组合请求动作（如前后一个动作依赖前一个动作的结果）这样能减少视图层逻辑的复杂度，增加应用的移植性，另外在saga中有管道的概念相同的动作能做到顺序执行并能暂停和重启回退这对于频繁的操作能起到很好的抗压作用。所以重要点其实不在视图层而是在redux应用的整个action动作的流程。 redux应用的中心redux应用的整体使用状态去控制，一个action触发的是一个操作状态ADD_DETAIL之类的。需要组织的是应用的状态管理。那么基础的元数据就是应用的状态一个函数是用来处理何种状态的。123对应关系db &lt;= service &lt;= controllerstore &lt;= action &lt;= view store1234567891011121314@Store(&apos;user&apos;)class User { constructor() {} @type(&apos;ADD_USER&apos;) function add(state, action) { ...... } @type(&apos;UPDATA_USER&apos;) function updata(state, action) { ...... }} action1234567891011121314@Action()class UserAction { constructor(user: User) {} @post(&apos;/api/user&apos;, &apos;json&apos;) function add(params) { return { type: user.ADD_USER params: { ...params } } }} view12345678910@Viewclass User extends React.Component { constructor() {}}function View(state, action) { return function(Target) { return connect(state, action)(Target) }} importnest中import完成了module中资源路径前前后关系，转换到前端可以用import去关系整个路由的前后关系。这样也省去前端去管理路由的额外的开发时间。 最主要的还是借鉴nest的方式想将应用的路由，api，状态管理的额外开发量合并到开发具体功能中省去这部分的时长。这部分的信息大多散落在各个文件中，不利于管理。","link":"/2019/05/30/typecript中的reflectApi元编程/"}],"tags":[{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"reflect","slug":"reflect","link":"/tags/reflect/"},{"name":"学习","slug":"学习","link":"/tags/学习/"}],"categories":[{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"},{"name":"会议","slug":"会议","link":"/categories/会议/"}]}